Объект является итератором, если он умеет обращаться к элементам коллекции по одному за раз, при этом отслеживая своё текущее положение внутри этой последовательности. В JavaScript итератор - это объект, который предоставляет метод next(), возвращающий следующий элемент последовательности. Этот метод возвращает объект с двумя свойствами: done и value.

После создания, объект-итератор может быть явно использован, с помощью вызовов метода next().

```js
function makeIterator(array) {
  let nextIndex = 0;

  return {
    next: function () {
      return nextIndex < array.length ?
       { value: array[nextIndex++], done: false } :
       { done: true };
    }
  };
}

const it = makeIterator(["yo", "ya"]);
console.log(it.next().value); // 'yo'
console.log(it.next().value); // 'ya'
console.log(it.next().done); // true
```

### Генератор
Генераторы - это специальный тип функции, который работает как фабрика итераторов. Функция становится генератором, если содержит один или более [`yield`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/yield) операторов и использует [`function*`](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/function*) синтаксис.
```js
function* idMaker() {
  let index = 0;
  while (true) yield index++;
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// ...
```

### Когда стоит использовать генераторы?
- Код, в котором используется генератор, сам определяет момент получения следующего значения. Генератор отвечает только за возврат значений, управление им осуществляется извне.
- Существуют асинхронные генераторы. Они позволяют работать с асинхронными потоками данных. 
Главное в генераторах — это то, что получить следующее значение, возвращаемое генератором, можно только тогда, когда оно нужно в коде, использующем генератор. Генераторы не возвращают всё за один раз. В некоторых ситуациях эта их особенность может оказаться весьма удобной.
- Возможность использовать spread (...) и for-of (по скольку итератор инстанции генератора это он же и есть).  
- Возможность lazy-вычислений — пожалуй это и есть самый главный козырь генераторов — вы можете засунуть туда сложный синхронный алгоритм, который можете спокойно ставить на паузу где вам угодно и "заводить" опять по мере необходимости. Более того, с помощью next() вы можете прокидывать новые данные внутрь уже работающего генератора.  
- Около-асинхронные трюки: по скольку генератор эффективно останавливает даже синхронный код в любой его точке исполнения — вы можете смело делать обертки-генераторы вокруг более сложных и времязатратных синхронных операций — и с помощью того же yield выходить на определенное время из работы — дабы дать остальным таскам, ожидающим в event-queue запуститься. То есть, иными словами, вы относительно безболезненно можете разбить сложную синхронную операцию на более мелкие — и эти мелкие запускать асинхронно — для того, чтобы браузер, например, не фризанул при каком-то сложном алгоритме.