[[Scope (область видимости)|Область видимости]] **let** — это блок, в котром переменная let объявлена и все его подблоки.

[[Scope (область видимости)|Область видимости]] **var** — вся функция, в которой переменная var была объявлена. (т.е. блок + его подблоки, но внутри подблоков сохраняется та же переменная, что была объявлена в функции).

```js
function demoFunc() {
	var a = 'start a';
	let b = 'start b';

	if (true) { // создаем новый блок
		a = 'new a'; // либо var a = '', т.к. для var не имеет значения  (именно для var)
		b = 'new b';

		console.log(a, b); // new a, new b
	}

	console.log(a, b); // new a, new b
}
```

### Недостатки var
1. Объявленная с помощью var переменная не ограничивается блоком кода, в котором она была создана. У нее функциональная область видимости -- это означает, что ее видимости ограничивает только функция. Обычный блок типа if, for, while. ее область видимости не ограничивает. Это может приводить к нежелательным эффектам.

2. Переменную  var можно переобъявлять.
```ts
var x = 1;
var x = 2; // ошибки не будет
```
Пример, почему это плохо:
```ts
var i = 321; // какой нибудь id

function doNothing() {};

for (var i = 0; i < 10; i++) {
	doNothing();
}

console.log(i); // 10
```

3. Переменная может быть использована до объявления. Это называется [[Hositing (всплытие, поднятие)|всплытие]]. Проблема в том, что var еще и инициализируется.
```ts
console.log(s); // undefined

var s = 0;
```
>[!note] Переменные созданные с помощью var не только объявляются, но инициализируются
>Инициализация -- присвоение значения. Т.е. при всплытии переменные [[Отличие var от let|var]] сразу получают значение undefined.
```ts
// a, c, d (d тоже в глобальной области видимости, т.к. блочная область видимости ее не ограничивает) все эти переменные проинициализированы как undefined
var a = 1;

function x() {
	var b = 2;
}

console.log(a, c) // 1, undefined

var c = 3;

if (true) {
	var d = 4;
}
```
4. Объявляя переменную через var в глобальной [[Scope (область видимости)|области видимости]] мы создаем новое свойство объекта window. А учитывая тот факт, что можно переобъявлять переменную, объявленную с помощью  var, мы можем случайно переписать свойство windows.
### Отличия let  и const от var
1. let и const создают переменные с блочной областью видимости. Это значит, что такие переменные не будут видны снаружи, если объявлены в блоке. Также let и const не будут видны вне функции.
```js
if (true) { // или while, или for
	var a = 1;
	let b = 2;
}
console.log(a); // 1
console.log(b); // ReferenceError: b is not defined
```
```js
function x() {
	var a = 1;
	let b = 2;
}

console.log(a); // ReferenceError: b is not defined
console.log(b); //
```

2. let и const нельзя использовать для повторного объявления переменной.
```js
let x = 1;
let x = 2; // Identifier 'x' has already been declared;
```

3. Переменные let и const видны только после объявления.
```js
console.log(a); // undefined
console.log(b); // ReferenceError: Cannot access 'b' before initialization
console.log(c);

var a = 1;
let b = 2;
const c = 3;
```

>[!note] const в объектах
>const не запрещает менять свойства объекта, это означает только то, что мы не можем переопределить переменную целиком.

```js
const language = {
	name: 'JS'
}

language.name = 'JavaScript';

console.log(language) // {name: JavaScript}
```

Читать также:
[[Scope (область видимости)]]
[[Hositing (всплытие, поднятие)]]
[[Temporal Dead Zone (TDZ, Временная Мертвая Зона)|Временная мертвая зона]]
