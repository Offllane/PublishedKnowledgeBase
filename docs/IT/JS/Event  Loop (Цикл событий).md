>[!error] Event loop не является частью движка JS (такого как V8 например). Event loop предоставляется средой (браузер или nodejs)
>Event loop в браузере и event loop в nodeJs решают одну проблему, но реализованы совсем по разному

Event Loop -- это отдельный механизм среды (браузера или nodejs например), который позволяет использовать неблокирующую модель ввода и вывода. Этот механизм осуществляет контроль стека вызовов и очереди обратных вызовов.

## Стек вызовов (Call stack)
Стек вызовов (call stack). (здесь добавить про структуру данных стек. Пока что достаточно знать, что принипы LIFO (Last input, first output)) За его обработку отвечает движок JavaScript. В стек вызовов поэтапно шаг за шагом складываются функции в том порядке, в котором они должны быть вызваны.

```js
function first() {  
    console.log('1');  
}  
  
function second() {  
    first();  
    console.log('2');  
}  
  
function third() {  
    second();  
    console.log('3');  
}  
  
third(); // 1, 2, 3
```
![[Pasted image 20230927234657.png]]
![[Pasted image 20230927234859.png]]

### Переполнение стека
Стек вызовов не бесконечный. При определенных условиях его можно переполнить и тогда приложение сломается. Стек ограничен по количеству находимых в нем функций.
![[Pasted image 20230927235152.png]]

### Задача на рекурсию и цикл
На собеседованиях часто дают рекурсивную задачу и спросят "Что будет, если передать туда очень большое число?". Как можно избежать переполнения стека. 
В данном случае можно переписать рекурсию на цикл. (Результат будет бесконечность, но приложение не крашнется).
```js
function factorialRec(n) {  
    if (n === 1) { return 1; }  
    return n * factorialRec(n - 1);  
}  

function factorial(n) {  
    let result = 1;  
    for (let i = n; i > 1; i--) {  
      result *= i;  
    }   
     return result;  
}
```

## Очередь задач (Task Queue)
В Event loop так же задействована очередь.
Все асинхронные операции, в которых ожидается вызов callback помещаются в очередь задач. Мы запоминаем коллбэк и регистриуем его. ![[Pasted image 20230928000916.png]]
>[!note] Задачи из очереди выполняются ТОЛЬКО после вызовов всех функций из стека

## Как задачи попадают в очередь?
У каждого браузера есть WebAPI. Это API предоставляет timeout, обработку слушателей событий нажатия на кнопки, события загрузки изображений, отправку fetch запросов.
```js
function log(value) {  
    console.log(value);  
}  
  
setTimeout(() => {  
    log('timeout');  
});
```

1. setTimeout попадает в стек вызовов![[Pasted image 20231013195422.png]]
2. setTimeout регистрируется webApi. На этом этапе запускается таймер ![[Pasted image 20231013195448.png]]
3. После того как таймер отсчитал все что нужно, мы отправляем колбэк в очередь вызовов ![[Pasted image 20231013195508.png]]
4. После того как стек вызовов очистился (т.к. из очереди вызовов задачи берутся только в том случае, когда стек вызовов пуст), выполняется колбэк![[Pasted image 20231013195527.png]]
### Порядок выполнения 
1. Выполнились все синхронные задачи.
2. После истечения таймера задача переносится в очередь вызовов. 
3. Задача из очереди вызовов задача переносится в стек вызовов (после того, как стек стал пустым).

## Макро и микро задачи
На самом деле в event loop используется не одна очередь задач, а две: очередь микрозадач (очередь событий) и очередь макрозадач (очередь задач);

![[Pasted image 20240220174533.png]]

Эти очереди не равнозначны, очередь микрозадач приоритетнее. В приоритете ВСЕГДА выполняются ВСЕ микрозадачи, а затем выполняются ПО ОДНОЙ макрозадаче.
![[Pasted image 20240220175120.png]]
![[Pasted image 20240220175248.png]]
Сначала по очереди выполняются все микротаски одна за одной (помним, что из очереди задач берутся задачи только при пустом стэке вызовов). Только после того как опустела очере

### Порядок выполнения
1. Сначала по очереди выполняются все микротаски одна за одной (помним, что из очереди задач берутся задачи только при пустом стэке вызовов).
2. Только после того как опустела очередь микрозадач берется ОДНА задача из очереди макрозадач. (Только при пустой очереди микрозадач)
![[Pasted image 20240220181129.png]]


```js
log(1);

setTimeout(() => {
  console.log(2);
}, 0);

Promise.resolve().then(() => {
  console.log(3);
});

console.log(4);

// 1 4 3 2
```

### Что создает микрозадачи?
1. Промисы (99% микротаск это промисы)
2. queueMicrotask (если микротаску надо создавать вручную)
3. mutationObserver (позволяет следить за изменениями в DOM)
### Что создает макрозадачи?
1. Таймеры (setTimeout, setInterval)
2. События (клик, загрузка изображения и т.п.)
3. Браузерные нюансы (рендер, инпут /аутпут и т.п.)

[[Задачи Event loop]]