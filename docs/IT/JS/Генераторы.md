Генератор — это синтаксический сахар для создания особого вида [[Функция итератор |итератора]], который, помимо метода `next()`, реализует два дополнительных метода `throw()` и `return()`.

Чтобы создать такой объект, нужно использовать **функцию-генератор**. Для её объявления к названию функции в начале добавляют символ звёздочки `*`.

Для возврата значений используются операторы `yield` или `yield*`. Они приостанавливают выполнение функции с полным сохранением промежуточных вычислений.

Оператор `yield*` перенаправляет итерации в другой генератор. Мы как бы делаем спред другого генератора внутри нашего, получаем его значения и возвращаем их.

Вызов метода `return()` завершает итерации и возвращает значение. Вызов метода `throw()` завершает итерации и бросает ошибку.
```js
function *getLangs() {  
    yield 'js';  
    yield 'java';  
    yield 'kotlin';  
    yield 'rust';  
}  
  
const generator = getLangs();  
  
console.log(generator.next()); // {value: 'js', done: false}  
console.log(generator.next()); // {value: 'java', done: false}  
console.log(generator.next()); // {value: 'kotlin', done: false}  
console.log(generator.next()); // {value: 'rust', done: false}}  
console.log(generator.next()); // {value: undefined, done: true}
```
Обратите внимание, что вызывать `return` в генераторе необязательно. Если `return` нет, то, после выполнения всех `yield`, следующий вызов `next()` вернёт 
`{ value: undefined, done: true }`

Так как генератор это ещё и **итерируемый объект**, то можно использовать его в цикле `for...of`.
```js
function *getLangs() {  
    yield 'js';  
    yield 'java';  
    yield 'kotlin';  
    yield 'rust';  
}  
  
const generator = getLangs();  
  
for (let values of generator) {  
    console.log(values); // js java kotlin rust  
}
```
>[!note] Оператор `yield` можно использовать исключительно внутри функции-генератора. То есть в колбэках использование `yield` приведёт к синтаксической ошибке.

```js
function* idMaker() {
  let index = 0;
  while (true) yield index++;
}

const it = idMaker();

console.log(it.next().value); // 0
console.log(it.next().value); // 1
console.log(it.next().value); // 2
// ...
```

### Отличие генератора от обычной функции
Чем функция-генератор отличается от обычной функции? Функции в JavaScript выполняются полностью, и в конце мы ожидаем получить результат.
```js
function createFullName(firstName, secondName) {
  return `${firstName} ${secondName}`
}

const fullName = createFullName('Анна', 'Каренина')
console.log(fullName)
// Анна Каренина
```

Функция-генератор возвращает объект-генератор. Из этого объекта можно получать данные, вызывая метод `next()`. При этом выполнение функции в буквальном смысле остановится.

```js
function imaginaryHeavyComputation() {  
    let result = 0;  
    for (let i = 0; i < 100; i++) {  
        result += i;
    }  
  
    return result;  
}  
  
function* getLangs() {  
    const result1 = imaginaryHeavyComputation()  
    console.log('result of heavy compuation #1:', result1);  
    yield 'java';  
  
    const result2 = imaginaryHeavyComputation()  
    console.log('result of heavy compuation #2:', result1 + result2);  
    yield 'js';  
  
    console.log("easy compuation:", 2 + 2)  
    yield 'rust';  
}  
  
const generator = getLangs();  
// Никаких логов и вызовов функций не произошло
```

Генераторы по умолчанию ленивые. До тех пор, пока не будет вызван метод `next()`, у возвращаемого объекта-генератора не будут происходить никакие вычисления. Но, даже после вызова `next()`, выполнение функции произойдёт только до первого вызова `yield`. Если вызвать `next()` ещё раз, то выполнение продолжится до следующего `yield` и так далее. Продолжим пример выше.

```js
console.log(generator.next())  
// 'result of heavy compuation #1: 4950'  
// { value: 'java', done: false }  
  
console.log(generator.next())  
// 'result of heavy compuation #2: 9900'  
// { value: 'js', done: false }  
  
console.log(generator.next())  
// 'easy compuation: 4'  
// { value: 'rust', done: false }
```

### Передача значений в генератор с `yield`
Вместе с генераторами в JavaScript был введён оператор `yield`. Как мы видели в примерах выше, `yield` приостанавливает функцию-генератор и возвращает значение. Можно представлять `yield` как двусторонний канал общения с генератором. С одной стороны мы получаем результат, с другой, можем передать значение в генератор в любой момент.

Добавим в предыдущий пример условие, что, если нам понравился первый язык программирования, мы учим другой похожий язык вместо JavaScript.

```js
function* getLangs() {  
    /**  
     * Первый вызов next в любом случае вернёт 'java',     * не имеет значения, передадим мы что-то в него или нет     *     * Переменная isFavorite при этом будет 'undefined'     */    
       const isFavorite = yield 'java';  
  
    /**  
     * Если мы передадим аргумент в 'next' при следующем вызове, то:     *     * 1) он будет присвоен переменной isFavorite;     * 2) условие будет верно, и мы получим значение 'kotlin'     */    
    if (isFavorite) {  
        yield 'kotlin'  
    } else {  
        /**  
         * или 'js', если вызовем 'next' без аргументов         */        
           yield 'js';  
    }  
    yield 'rust';  
}  
  
const generator = getLangs();  
  
console.log(generator.next());  
// { value: 'java', done: false }  
  
// Передаём true, потому что нам понравился Java  
console.log(generator.next(true));  
// { value: 'kotlin', done: false }
```

Может показаться нелогичным, что при первом вызове `next()` значение аргумента не запишется. Такое поведение генераторов связано с их «ленивостью». Первый вызов `next()` можно считать инициализацией.

Если представить генератор как закрытую коробку, то первый вызов `next()` — это как вытянуть первый предмет вслепую. Заранее неизвестно, что мы получим, и потому нельзя заранее сказать, что предмет нам понравится. Аналогично и в примере выше. Сначала мы хотим получить результат, а затем, на его основе, можем решить, какой аргумент передать в следующий вызов `next()`.

Так что мы не можем передать значение в `isFavorite` в первом вызове `next()`, но можем в следующем. Сначала генератор вернёт значение, а только потом запишет переданный ему аргумент.

Используя возможность передачи данных в генератор, можно по ходу его выполнения менять возвращаемые значения и создавать очень гибкие конструкции.

### Вызов генератора внутри другого генератора
Если к вызову оператора `yield` добавить звёздочку `*`, то можно перенаправить выполнение в другой генератор.

Снова дополним наш пример и предположим, что, если нам понравился язык `java`, то мы хотим попробовать несколько языков на базе JVM.
```js
function* jvmLangs() {
  yield 'kotlin'
  yield 'scala'
  yield 'closure'
}

function* getLangs() {
  const isFavorite = yield 'java';

  if (isFavorite) {
    /**
     * Обратите внимание на звёздочку
     *
     * Данная строка то же самое, что и:
     * yield 'kotlin'
     * yield 'scala'
     * yield 'closure'
     *
    */
    yield* jvmLangs()

  } else {
    yield 'js';
  }

  yield 'rust';
}
```
Так можно вызывать генераторы внутри генераторов и удобно разбивать логику на отдельные части.
### Когда стоит использовать генераторы?
- Код, в котором используется генератор, сам определяет момент получения следующего значения. Генератор отвечает только за возврат значений, управление им осуществляется извне.
- Существуют асинхронные генераторы. Они позволяют работать с асинхронными потоками данных. 
Главное в генераторах — это то, что получить следующее значение, возвращаемое генератором, можно только тогда, когда оно нужно в коде, использующем генератор. Генераторы не возвращают всё за один раз. В некоторых ситуациях эта их особенность может оказаться весьма удобной.
- Возможность использовать spread (...) и for-of (поскольку итератор инстанции генератора это он же и есть).  
- Возможность lazy-вычислений — пожалуй это и есть самый главный козырь генераторов — вы можете засунуть туда сложный синхронный алгоритм, который можете спокойно ставить на паузу где вам угодно и "заводить" опять по мере необходимости. Более того, с помощью next() вы можете прокидывать новые данные внутрь уже работающего генератора.  
- Около-асинхронные трюки: по скольку генератор эффективно останавливает даже синхронный код в любой его точке исполнения — вы можете смело делать обертки-генераторы вокруг более сложных и времязатратных синхронных операций — и с помощью того же yield выходить на определенное время из работы — дабы дать остальным таскам, ожидающим в event-queue запуститься. То есть, иными словами, вы относительно безболезненно можете разбить сложную синхронную операцию на более мелкие — и эти мелкие запускать асинхронно — для того, чтобы браузер, например, не фризанул при каком-то сложном алгоритме.